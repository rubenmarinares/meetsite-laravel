Documentaci√≥n:


Base proyecto: https://www.youtube.com/watch?v=f9FKZE4C3vE

Instalamos Fortify(paquete para la gesti√≥n de usuarios)
    https://www.youtube.com/watch?v=5c9iJ3hWpk4

Instalamos Spatie(gesti√≥n de roles y permisos)

SPATIE (para permisos y roles) https://www.youtube.com/watch?v=nKtJEezp7WI




CUANDO creamos el modelo tenemos que definier para que se va a utilizar y en la tabla de exportaci√≥n
tenemos que a√±adrile los campo que queremos que tengan
php artisan make:model


{{ dd($menuitems) }}
@php dd($menuitems); @endphp



Quiero crear un array de academias en session cuando el usuario se loguee por lo que voy a generar un controller:
php artisan make:controller Auth/AuthenticatedSessionController

Despu√©s implementamos el m√©todo store dentro del controller


Y sobreescribimos la direcci√≥n de login de fortify
use App\Http\Controllers\Auth\AuthenticatedSessionController;

Route::post('/login', [AuthenticatedSessionController::class, 'store'])->middleware(['guest'])->name('login');


php artisan db:seed

Generar tabla pivot:
php artisan make:migration create_role_user_table

php artisan make:migration create_email_table

//LANZAR migration
php artisan migrate

A√ëADIR UN CAMPO EN UNA TABLA YA CREADA
php artisan make:migration add_userid_to_emails_table --table=emails


PREPARAR TRAIT EN LARAVEL PARA REUTILIZAR C√ìDIGO

<?php

namespace App\Traits;

use App\Models\Academia;
use App\Models\Profesor;
use Illuminate\Support\Facades\Auth;

trait PreparaFormularioProfesor
{
    public function prepararFormularioProfesor(array $data = []): array
    {
        $user = Auth::user();

        if ($user->hasRole('super-admin')) {
            $academias = Academia::query()->orderByRaw('academia')->get();
            $menu = true;
        } else {
            $academias = Academia::query()
                ->whereHas('users', function ($query) use ($user) {
                    $query->where('users.id', $user->id);
                })
                ->orderByRaw('academia')->get();
            $menu = false;
        }

        return [
            'profesor' => new Profesor(),
            'submitButtonText' => 'Crear Profesor',
            'actionUrl' => route('profesores.store'),
            'method' => 'POST',
            'h2Label' => 'Crear Profesor',
            'academiasSeleccionadas' => $data['academias'] ?? [],
            'academias' => $academias,
            'menu' => $menu,
            'metaUrlForm' => route('profesores.create'),
            'data' => $data,
        ];
    }
}
üß© Paso 2: Usar el Trait en el Controller
php
Copiar
Editar
use App\Traits\PreparaFormularioProfesor;

class ProfesorController extends Controller
{
    use PreparaFormularioProfesor;

    public function create(): View
    {
        $vars = $this->prepararFormularioProfesor();

        return view('profesores.partials.form', $vars);
    }
}
üß© Paso 3: Usar el Trait en ProfesorRequest
php
Copiar
Editar
use App\Traits\PreparaFormularioProfesor;
use Illuminate\Contracts\Validation\Validator;
use Illuminate\Http\Exceptions\HttpResponseException;
use Illuminate\Support\ViewErrorBag;

class ProfesorRequest extends FormRequest
{
    use PreparaFormularioProfesor;

    public function failedValidation(Validator $validator)
    {
        $viewErrors = new ViewErrorBag();
        $viewErrors->put('default', $validator->errors());

        $formVars = $this->prepararFormularioProfesor($this->all());

        $view = view('profesores.partials.form', array_merge(
            $formVars,
            ['errors' => $viewErrors]
        ))->render();

        throw new HttpResponseException(
            response($view, 422)
        );
    }
}

//TODO
-Setear la academia en la que estamos cuando entramos en ella--> LISTO
-Configurar la edici√≥n de la academia cuando estamos en el panel principal(sidebar) -->LISTO
-Filtrar a los alumnos de los clientes linkados por academia seleccionada -->LISTO
-Creaci√≥n del modelo grupos (ESTAMOS EN ELLO)--> A√ëADIR ALUMNOS/ PROFESORES / ASIGNATURAS
-FILTRAR COMBO ACADEMIAS DE LOS ELEMENTOS CON EL VALOR SELECCIONADO en SESSION
-Generar calendario
-Eliminar en el listado gen√©rico de clientes los duplicaod de academias
-DATOS FISCALES DE ACADEMIAS



-Restauraci√≥n de password --> LISTO, Faltan detalles de implementaci√≥n como mensajes en los distintos steps donde se solicita
-Asistencia alumnos.
    Desde la pesta√±a de alumnos podremos guardar la asistencia de un alumno a sus grupos:
        -Un grupo puede tener varios alumnos
        -Un grupo tiene un horario
        -Un grupo tiene un profesor
        -Un grupo puede estar en varias aulas, dependiendo del d√≠a.

    Desde la pesta√±a de alumnos veremos los grupos en los que est√° el usuario y podremos abrir el enlace asistecia grupo
        Dentro de esta p√°gina aparecer√° el d√≠a y hora en los que el alumno tiene clase con los checks para marcar la asistencia
        Check para marcar asistencia y un input de observaciones

    Esta pesta√±a la podremos generar de manera din√°mica con buscadores:
        desplegable de alumnos/ desplegable de grupos

    Asistencia abrir√° nueva pesta√±a--> Creamos controlador Asistencia 

Vista de  PARA MARCAR LA ASISTENCIA DE USUARIOS A GRUPOS:

GRUPO 1
| Alumno     | 01/10 | 03/10 | 08/10 | 10/10 | ... |
| ---------- | ----- | ----- | ----- | ----- | --- |
| Juan P√©rez | ‚úÖ     | ‚ùå     | ‚úÖ     | ‚úÖ     | ... |
| Ana L√≥pez  | ‚úÖ     | ‚úÖ     | ‚ùå     | ‚úÖ     | ... |


GRUPO 2
| Alumno     | 02/10 | 03/10 | 04/10 | 05/10 | ... |
| ---------- | ----- | ----- | ----- | ----- | --- |
| Juan P√©rez | ‚úÖ     | ‚ùå     | ‚úÖ     | ‚úÖ     | ... |
| Ana L√≥pez  | ‚úÖ     | ‚úÖ     | ‚ùå     | ‚úÖ     | ... |




PROPUESTA DE MODELO PARA ASISTENCIA:

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Asistencia extends Model
{
    protected $table = 'asistencia';

    // Desactivamos incremento autom√°tico porque no hay campo "id"
    public $incrementing = false;

    // Si usas clave primaria compuesta (grupoid, alumnoid, fecha), Eloquent no las maneja de forma nativa.
    // Puedes dejar la PK "sin definir" y trabajar con save/update/delete mediante query builder
    // o usar un paquete externo como "eloquent-composite-primary-key".
    protected $primaryKey = null;

    protected $fillable = [
        'grupoid',
        'alumnoid',
        'fecha',
    ];

    protected $casts = [
        'fecha' => 'date',
    ];

    // Relaciones
    public function grupo()
    {
        return $this->belongsTo(Grupo::class, 'grupoid');
    }

    public function alumno()
    {
        return $this->belongsTo(Alumno::class, 'alumnoid');
    }
}

COMO USARLO EN EL CONTROLADOR:
use App\Models\Asistencia;

public function registrar(Request $request)
{
    Asistencia::create([
        'grupoid' => $request->grupoid,
        'alumnoid' => $request->alumnoid,
        'fecha' => now()->toDateString(), // formato YYYY-MM-DD
    ]);

    return response()->json(['ok' => true]);
}




-Comunicaciones
    generaremos una nueva pesta√±a de comunicaciones desde donde podremos gestionar la comunicaci√≥n de nuestra herramienta
    con los usuarios potenciales(profesore, alumnos, clientes, usuarios)

    Dentro de comunicaciones haremos apartado
        -plantillas email
        -emails enviados-->filtros
        -programar env√≠o
        

            idemail
            nombre(plantilla)
            created
            plantilla 1/0

            Secciones:
                100%
                2 columns
                3 columns
                4 columns
            
                insert("ecb_emails_rows",array(
                "idrow"=>intval($maxid[0]["idrow"]+1),
                "idtyperow"=>intval($_REQUEST["idtyperow"]),
                "properties"=>json_encode($properties),
                "sort"=>intval($_REQUEST["position"]),
                "idemail"=>intval($_REQUEST["idemail"])


            Content:
                Header
                Image
                Title
                Paragraph
                Button
                Divider
                List
                Html
                Footer

                $resul=$db->insert("ecb_emails_blocks",array(
                        "idblock"=>intval($maxid[0]["idblock"]+1),
                        "idtypeblock"=>intval($_REQUEST["idtypeblock"]),
                        "idrow"=>intval($_REQUEST["idrow"]),
                        "col"=>intval($_REQUEST["col"]),
                        "properties"=>json_encode($properties),
                        "sort"=>intval($_REQUEST["position"]),
                        "idemail"=>intval($_REQUEST["idemail"]),
                    ));

            Concepto de col, que hace referencia en que col se inserta





    Plantillas de email:
        tendremos un listado donde podremos gestionar las plantillas de email 
            las plantillas de email nos basaremos en la herramienta emailbuilder. 

    Emails enviados->mostraremos el listado de emails que hemos enviado(y ver si se ha leido), podremos entrar en el detalle              
        para ver a que usuarios se ha enviado
    
    Programar env√≠o:
        Seleccionaremos una plantilla o un texto que enviaremos con la fecha programada(control de fechas, solo lo podremos enviar una vez)
        No dejaremos enviar m√°s de 15 veces un correo.



NUEVO ELEMENTO BLOQUES DE EMAIL

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class EmailBlock extends Model
{
    protected $table = 'email_blocks';

    protected $fillable = [
        'sectionid',   // referencia a email_sections.id
        'blockid',     // referencia al tipo de bloque (blocks.id)
        'col',         // n√∫mero de columna (1, 2, 3, 4)
        'order'        // posici√≥n dentro de la columna
    ];

    public function emailSection()
    {
        return $this->belongsTo(EmailSection::class, 'sectionid');
    }

    public function block()
    {
        return $this->belongsTo(Block::class, 'blockid');
    }
}

CREATE TABLE email_blocks (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    sectionid BIGINT UNSIGNED NOT NULL,
    blockid BIGINT UNSIGNED NOT NULL,
    col TINYINT UNSIGNED NOT NULL DEFAULT 1,
    `order` INT UNSIGNED NOT NULL DEFAULT 0,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,

    CONSTRAINT fk_email_blocks_section FOREIGN KEY (sectionid)
        REFERENCES email_sections(id) ON DELETE CASCADE,

    CONSTRAINT fk_email_blocks_block FOREIGN KEY (blockid)
        REFERENCES blocks(id) ON DELETE CASCADE
);


EmailSection.php
public function blocks()
{
    return $this->hasMany(EmailBlock::class, 'sectionid')
                ->orderBy('col')
                ->orderBy('order');
}

EmailBlock.php
public function emailSection()
{
    return $this->belongsTo(EmailSection::class, 'sectionid');
}

public function block()
{
    return $this->belongsTo(Block::class, 'blockid');
}

üöÄ Ejemplo de uso
// Obtener todas las secciones de un email con sus bloques organizados
$email = Email::with(['sections.blocks'])->find($emailId);

// Acceder a los bloques de la primera secci√≥n, columna 2
$blocksCol2 = $email->sections->first()->blocks->where('col', 2);

<div id="section12-col2" class="RowBlocks" data-idsection="12" data-col="2"></div>
Puedes usar col directamente para saber d√≥nde insertar el bloque:

js
Copiar c√≥digo
addBlock(sectionId, blockId, col, order)
Y guardarlo as√≠:

php
Copiar c√≥digo
EmailBlock::create([
    'sectionid' => $sectionId,
    'blockid' => $blockId,
    'col' => $col,
    'order' => $order
]);



create_email_blocks_table.php

Gu√°rdalo en database/migrations/YYYY_MM_DD_HHMMSS_create_email_blocks_table.php
(usa php artisan make:migration create_email_blocks_table para generarlo y luego reemplaza el contenido).

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('email_blocks', function (Blueprint $table) {
            $table->id();

            // üîó Relaci√≥n con email_sections
            $table->foreignId('sectionid')
                  ->constrained('email_sections')
                  ->onDelete('cascade');

            // üîó Relaci√≥n con blocks
            $table->foreignId('blockid')
                  ->constrained('blocks')
                  ->onDelete('cascade');

            // üß© Columna dentro de la secci√≥n (1 a 4)
            $table->tinyInteger('col')->default(1)->comment('N√∫mero de columna dentro de la secci√≥n');

            // üî¢ Orden del bloque dentro de la columna
            $table->integer('order')->default(0)->comment('Posici√≥n del bloque en la columna');

            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('email_blocks');
    }
};


üß© Modelo EmailBlock.php

Crea en app/Models/EmailBlock.php:

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class EmailBlock extends Model
{
    protected $table = 'email_blocks';

    protected $fillable = [
        'sectionid',
        'blockid',
        'col',
        'order',
    ];

    public function emailSection()
    {
        return $this->belongsTo(EmailSection::class, 'sectionid');
    }

    public function block()
    {
        return $this->belongsTo(Block::class, 'blockid');
    }
}

üîó Actualiza tambi√©n tu modelo EmailSection.php:
public function blocks()
{
    return $this->hasMany(EmailBlock::class, 'sectionid')
                ->orderBy('col')
                ->orderBy('order');
}

üß† Ejemplo de uso
// A√±adir un bloque a una secci√≥n y columna concreta
EmailBlock::create([
    'sectionid' => $sectionId,
    'blockid' => $blockId,
    'col' => 2,     // columna 2
    'order' => 1    // primer bloque
]);

// Obtener bloques de la secci√≥n ordenados por columna y posici√≥n
$blocks = EmailSection::with('blocks')->find($sectionId);





//MAILABLE PERSONALIZADO


 php artisan make:mail CustomHtmlEmail

‚úÖ 1Ô∏è‚É£ Crear un Mailable personalizado

Ejecuta en consola:

php artisan make:mail CustomHtmlEmail


Esto crear√° el archivo:
app/Mail/CustomHtmlEmail.php

‚úÖ 2Ô∏è‚É£ Editar el CustomHtmlEmail

Abre ese archivo y modif√≠calo as√≠:

<?php

namespace App\Mail;

use Illuminate\Bus\Queueable;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;

class CustomHtmlEmail extends Mailable
{
    use Queueable, SerializesModels;

    public string $subjectText;
    public string $htmlContent;

    /**
     * Create a new message instance.
     */
    public function __construct(string $subjectText, string $htmlContent)
    {
        $this->subjectText = $subjectText;
        $this->htmlContent = $htmlContent;
    }

    /**
     * Build the message.
     */
    public function build()
    {
        return $this->subject($this->subjectText)
                    ->html($this->htmlContent);
    }
}


üîπ Aqu√≠ usamos ->html() directamente para renderizar HTML ‚Äúraw‚Äù (sin necesidad de una vista Blade).
üîπ Si prefieres una vista Blade, puedes usar ->view('emails.tu_vista').

‚úÖ 3Ô∏è‚É£ Enviar el email desde tu controlador

Por ejemplo, en EmailController o cualquier otro:

use Illuminate\Support\Facades\Mail;
use App\Mail\CustomHtmlEmail;

public function sendCustomEmail(Request $request)
{
    $to = 'usuario@ejemplo.com';
    $subject = 'Bienvenido a Meetsite!';
    $html = '
        <h1 style="color:#0A879F;">¬°Hola!</h1>
        <p>Este es un correo de prueba con contenido HTML personalizado.</p>
        <p>Enviado desde Laravel üíå</p>
    ';

    Mail::to($to)->send(new CustomHtmlEmail($subject, $html));

    return response()->json(['message' => 'Correo enviado correctamente a '.$to]);
}

‚úÖ 4Ô∏è‚É£ Si prefieres usar una vista Blade

Crea el archivo:
resources/views/emails/custom.blade.php

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>{{ $subject }}</title>
</head>
<body style="font-family:Arial, sans-serif;">
  <h1 style="color:#0A879F;">Hola {{ $name ?? '' }}!</h1>
  <p>{{ $messageBody }}</p>
</body>
</html>


Y en tu CustomHtmlEmail.php cambias:

public function build()
{
    return $this->subject($this->subjectText)
                ->view('emails.custom')
                ->with([
                    'subject' => $this->subjectText,
                    'name' => 'Pepe',
                    'messageBody' => 'Este es un correo de prueba con Blade.'
                ]);
}

‚úÖ 5Ô∏è‚É£ Configuraci√≥n de correo (ya la tienes)

Como tu email de recuperaci√≥n funciona, no necesitas tocar .env, pero por si acaso, verifica que tengas algo as√≠:

MAIL_MAILER=smtp
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=tu_usuario@gmail.com
MAIL_PASSWORD=tu_contrase√±a_o_token
MAIL_ENCRYPTION=tls
MAIL_FROM_ADDRESS=no-reply@tudominio.com
MAIL_FROM_NAME="Meetsite"

‚úÖ 6Ô∏è‚É£ Resultado final

Puedes enviar emails con HTML libre o con Blade a cualquier destinatario, ejemplo:

Mail::to('cliente@empresa.com')->send(new CustomHtmlEmail(
    'Notificaci√≥n importante',
    '<strong>Hola!</strong><br>Este es un mensaje enviado desde Laravel con HTML personalizado.'
));